# android-pay

## 接口描述

### Android Pay Verify and Decrypt

Performs signature verification and decryption of Android Pay token data.

```
POST /core/android-pay/verify-and-decrypt
```

**Example Request**

```json
POST /core/android-pay/verify-and-decrypt HTTP/1.1
Content-Type: application/json; charset=utf-8
Host: localhost:3000
 
{
    "encryptedPrivateKey": "MIIClzCCAX8CEQCVilPk3XweAOTIqRLQ6s2/MA0GCSqGSIb3DQEBC ...",
    "paymentToken": {
        "encryptedMessage": "ZW5jcnlwdGVkTWVzc2FnZQ==",
        "ephemeralPublicKey": "ZXBoZW1lcmFsUHVibGljS2V5",
        "tag": "c2lnbmF0dXJl"
    }
}
```

**Example Response**

```json
HTTP/1.1 200 OK
content-type: application/json; charset=utf-8
 
{
    "verified": true,
    "tokenData": "AvDG63LLv8a3+blOkeDtOf38YWDmk2tC5xFV ...",
    "requestId": "1418659162408:cas0stl1:37952:i3kppbil:10435",
    "rotatedCipher": "IKoZIzj0DAQcDQ ...",
    "rotatedKeyAlias": "dev-test-aes-256-3"
}
```

**Request JSON   Object:**

* **encryptedPrivateKey** (*buffer*) – The merchant’s private   key material, previously encrypted by CaaS. 
* **paymentToken** (*object*) – The literal payment   token object that was generated by the device. This payment token should be   serialized directly into a JSON object on the device and sent completely   unmodified directly to CaaS.

**Response JSON   Object:**
* **verified** (*boolean*) – Indicates whether the payment token’s signature was successfully verified. This does **NOT** inspect   the signing time of the signature to prevent a possible replay attack.
* **tokenData** (*buffer*) – This is the raw decrypted stream of bytes that represent the EMV or 3D Secure payment token   data. Typically this is a JSON object that has been base64 encoded. 
* **rotatedCipher** (*buffer*) – This is an **optional** response value that indicates your encryption key for this request has been rotated. CaaS has re-encrypted your old data with the newly-rotated key and has   provided you that new value so that you may update your records.
* **rotatedKeyAlias** (*string*) – This is an **optional** response value that indicates which key was used when calculating the **rotatedCipher** value above.

## 业务流程
### 如何解密付款令牌

> 注意：该流程属于[官方文档](<https://developers.google.cn/pay/api/web/guides/resources/payment-data-cryptography#decrypt-token>)

1. 使用 `encryptedPrivateKey` 和 `ephemeralPublicKey` 来推导出长度为 512 位且采用 ECIES-KEM 的共享密钥。请使用以下参数：

   - 椭圆曲线：NIST P-256（在 OpenSSL 中也称为 prime256v1）。

   - CheckMode、OldCofactorMode、SingleHashMode 和 CofactorMode 为 0。
   - 编码函数：未压缩的点格式。
   - 密钥推导函数：HKDFwithSHA256（如 [RFC 5869 中所述](https://tools.ietf.org/html/rfc5869)），它具有以下参数：
     - 请勿提供盐。根据 RFC，这必须等同于 32 个零字节的盐。

2. 将生成的密钥拆分为两个长度为 256 位的密钥：`symmetricEncryptionKey` 和 `macKey`。

3. 验证 `tag` 字段是否为 `encryptedMessage` 的有效 MAC。

   要生成预期的 MAC，请使用采用散列函数 SHA256 的 HMAC ([RFC 5869](https://tools.ietf.org/html/rfc5869)) 以及在第 2 步中取得的 `macKey`。

   **注意**：请记得使用恒定时间数组比较来避免时序攻击。

4. 使用具有以下项目的 AES-256-CTR 模式解密 `encryptedMessage`：

   - 零 IV。
   - 未填充。
   - 第 2 步中推导出的 `symmetricEncryptionKey`。

### 利用上述流程获得入参以作校验

1. 使用 `/core/generate/ecc` 接口生成一个密钥对，得到参数 encryptedPrivateKey、publicKey，这时两个参数都是 Base64 格式。
2. 使用 `/core/decrypt/aes` 接口解密 encryptedPrivateKey，得到 PKCS8 格式的私钥。
3. 将 公钥私钥分别转成 ECPublicKey、ECPrivateKey

```java
// 公钥
ECPublicKeySpec ecPublicKeySpec = new ECPublicKeySpec(ecSpec.getCurve().decodePoint(publicKeyOutSide), ecSpec);
ECPublicKey ecPublicKey = (ECPublicKey) factory.generatePublic(ecPublicKeySpec);

// 私钥
PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKeyOutSide);
ECPrivateKey ecPrivateKey = (ECPrivateKey) factory.generatePrivate(pkcs8EncodedKeySpec);
```

4. 使用 Google Tink 库和 publicKey，可以协商出共享密钥，最后得到临时公钥（ephemeralPublicKey）和 symmetricKey（symmetricKey = symmetricEncryptionKey + macKey）。

> ！！ 注意：使用 Google Tink 库时，需要先注册 `TinkConfig.register();` ！！

5. 将 symmetricKey 拆分为 symmetricEncryptionKey 和 macKey，两者各占一半。

6. 随意编写一段明文，如：1234567812345678，再使用 symmetricEncryptionKey 加密明文，得到 encryptedMessage

> 注意：encryptedMessage = IV + 1234567812345678的密文

```java
// 使用 symmetricEncryptionKeyHex 加密明文，得到 encryptedMessage
final String plainText = "1234567812345678";
SecretKey aesSymmetrickey = new SecretKeySpec(Hex.Hex.decode(symmetricEncryptionKey), "AES");
Cipher encrypt = Cipher.getInstance("AES/CTR/NoPadding", provider);
IvParameterSpec ivParameterSpec = new IvParameterSpec("0000000000000000".getBytes("UTF-8"));
encrypt.init(Cipher.ENCRYPT_MODE, aesSymmetrickey, ivParameterSpec);
final byte[] encryptResult = Bytes.concat(ivParameterSpec.getIV(), 			encrypt.doFinal(plainText.getBytes("UTF-8")));
final String encryptedMessage = Base64.Base64.encode(encryptResult);
System.out.println("encryptedMessage By Base64: " + encryptedMessage);
```

7. 使用 macKey 对上述的 encryptedMessage 计算 MAC

> 注意：计算 mac，需要放入 encryptedMessage + aadLengthInBits

```java
// 使用 macKeyHex 对 encryptedMessage 计算 MAC
byte[] aadLengthInBits = Arrays.copyOf(ByteBuffer.allocate(8).putLong(8L * 0).array(), 8);
final Mac mac = Mac.getInstance("HMACSHA256", provider);
SecretKey macKey = new SecretKeySpec(Hex.Hex.decode(macKeyHex), "HMAC");
mac.init(macKey);
mac.update(encryptResult);
mac.update(aadLengthInBits);
final byte[] hmac = mac.doFinal();
System.out.println("tag By Base64: " + Base64.Base64.encode(hmac));
System.out.println("tag by Hex: " + Hex.Hex.encode(hmac));
```

8. 组合最终需要解密的密文，ciphertext = ephemeralPublicKey + encryptResult + hmac

```java
final byte[] ciphertext = Bytes.concat(ephemeralPublicKeyFromGoogle, encryptResult, hmac);
```

9. 调用 Google Tink 库中的解密方法，进行解密验证，解密所得结果与明文一致。

> 注意：
>
> 1. RegistryEciesAeadHkdfDemHelper 类不是 public 类型的类，所以无法直接使用，可以将 Google Tink 中的该类复制到自己项目中并创建类，在自己创建的类中加上 public 让自己可以使用。
> 2. RegistryEciesAeadHkdfDemHelper 该类的发现是从 Google PAY API 官方文档中的[验证代码](<https://developers.google.cn/pay/api/android/guides/resources/payment-data-cryptography#decrypt-token>)中发现。

```java
final byte[] decryptMessage = new EciesAeadHkdfHybridDecrypt(ecPrivateKey, salt, 	 "HmacSha256", EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(AeadKeyTemplates.AES256_CTR_HMAC_SHA256)).decrypt(ciphertext, null);
System.out.println("decryptMessage: " + new String(decryptMessage, "UTF-8"));
```

#### 另一种方法获得 ciphertext

从上面第 9 步中可以看到 EciesAeadHkdfHybridDecrypt 类，其实还存在类 EciesAeadHkdfHybridEncrypt。使用该类，可以直接获得第 8 步中需要的 ciphertext。

ciphertext 经过上述第 9 步解密后同样可以得到正确的明文。

```java
final byte[] encryptMessageFromGoogle = new EciesAeadHkdfHybridEncrypt(ecPublicKey, salt, "HmacSha256", EllipticCurves.PointFormatType.UNCOMPRESSED, new RegistryEciesAeadHkdfDemHelper(AeadKeyTemplates.AES256_CTR_HMAC_SHA256)).encrypt("1234567812345678".getBytes("UTF-8"), null);
System.out.println("Google encryptMessage: " + Hex.Hex.encode(encryptMessageFromGoogle));
```

## 使用万事达接口验证

使用万事达已有的 `/core/android-pay/verify-and-decrypt` 接口验证时，无法通过验证。原因不明。

响应值大概如下：

```json
{
    "verified": false,
    "tokenData": "h01MbHOGmRulmq55ugU/C6MyJyUpHcQ9rkB4EkPzfPA=",
	"requestId": xxx
}
```

tokenData 值无法解释，是不可见字符。

需要知道：

1. verified 值是如何得到的，它代表着什么意思？

> 在接口描述中：
>
> verified (boolean) – Indicates whether the   payment token’s signature was successfully verified. This does NOT inspect   the signing time of the signature to prevent a possible replay attack.
>
> verified（boolean） - 指示是否已成功验证付款令牌的签名。但这不检查签名的签约时间，以防止可能的重放攻击。

2. tokenData 是否为解密 加密信息 后返回的明文？

3. 希望可以有更详细的流程解释和测试例子。

## 使用R2D2库的ECV0测试数据，发到万事达接口测试

[R2D2库链接](https://github.com/spreedly/r2d2)

> R2D2中包含里 ECv0 和 ECv1，但 ECv0 才是 AndroidPay
>
> 从以下代码可知：
>
> ```ruby
> case protocol_version
>  when 'ECv0'
>    AndroidPayToken.new(token_attrs)
>  when 'ECv1'
>    raise ArgumentError, "missing keyword: recipient_id" if recipient_id.nil?
>    raise ArgumentError, "missing keyword: verification_keys" if verification_keys.nil?
> 
>    GooglePayToken.new(token_attrs, recipient_id: recipient_id, verification_keys: verification_keys)
> ```

使用 R2D2 的 ECv0 数据进行测试，**测试成功**。原数据如下：

```
encryptedMessage:
V65NNwqzK0A1bi0F96HQZr4eFA8fWCatwykv3sFA8Cg4Wn4Ylk/szN6GiFTuYQFrHA7a/h0P3tfEQd09bor6pRqrM8/Bt12R0SHKtnQxbYxTjpMr/7C3Um79n0jseaPlK8+CHXljbYifwGB+cEFh/smP8IO1iw3TL/192HesutfVMKm9zpo5mLNzQ2GMU4JWUGIgrzsew6S6XshelrjE

ephemeralPublicKey:
BB9cOXHgf3KcY8dbsU6fhzqTJm3JFvzD+8wcWg0W9r+Xl5gYjoZRxHuYocAx3g82v2o0Le1E2w4sDDl5w3C0lmY=

tag: 
boJLmOxDduTV5a34CO2IRbgxUjZ9WmfzxNl1lWqQ+Z0=

PrivateKey(PKCS8 格式):
MHcCAQEEIDnEBl2fHeMqFqePupLh6RTQM6Ro16v8JjIAVXcHp4ktoAoGCCqGSM49AwEHoUQDQgAEa6fxL04JEhOi/+1QzTHuh6d+qoEizAo79xNkJ5xvaeizZv2wBRV+cynhOeThDf8FJDE4TIGL0G+a4zlrM3wqNw==
```

需要先使用万事达的加密接口加密 PrivateKey，得到本接口参数 encryptedPrivateKey：

```
PrvK5yZyi2BZ6zYpdl4AQhB7kaaE4vZ3UTIBXW0VXbYLw+93gdllHBDeFMRiubXCCWYW5/ORml98haIY97OCgCuhMSvFFH6lsXjPAMHg8Qd3KMmRkApKoAnGl9DjbN3Bdf9MD5a0A1vnNWWFJeRbzVP4KinC8m/XY2dd5DzEwBHhMkeJdv4srGi3bqB6Gulem3fOj/koXnpJnP4/LwOWxmE=
```

请求数据：

```json
{
"encryptedPrivateKey":"PrvK5yZyi2BZ6zYpdl4AQhB7kaaE4vZ3UTIBXW0VXbYLw+93gdllHBDeFMRiubXCCWYW5/ORml98haIY97OCgCuhMSvFFH6lsXjPAMHg8Qd3KMmRkApKoAnGl9DjbN3Bdf9MD5a0A1vnNWWFJeRbzVP4KinC8m/XY2dd5DzEwBHhMkeJdv4srGi3bqB6Gulem3fOj/koXnpJnP4/LwOWxmE=",
"paymentToken": {
    "encryptedMessage": "V65NNwqzK0A1bi0F96HQZr4eFA8fWCatwykv3sFA8Cg4Wn4Ylk/szN6GiFTuYQFrHA7a/h0P3tfEQd09bor6pRqrM8/Bt12R0SHKtnQxbYxTjpMr/7C3Um79n0jseaPlK8+CHXljbYifwGB+cEFh/smP8IO1iw3TL/192HesutfVMKm9zpo5mLNzQ2GMU4JWUGIgrzsew6S6XshelrjE",
    "ephemeralPublicKey": "BB9cOXHgf3KcY8dbsU6fhzqTJm3JFvzD+8wcWg0W9r+Xl5gYjoZRxHuYocAx3g82v2o0Le1E2w4sDDl5w3C0lmY=",
	"tag": "boJLmOxDduTV5a34CO2IRbgxUjZ9WmfzxNl1lWqQ+Z0="
	}
}
```

响应数据

```json
{
	"verified": true,
    "tokenData": "eyJkcGFuIjoiNDg5NTM3MDAxMjAwMzQ3OCIsImV4cGlyYXRpb25Nb250aCI6MTIsImV4cGlyYXRpb25ZZWFyIjoyMDIwLCJhdXRoTWV0aG9kIjoiM0RTIiwiM2RzQ3J5cHRvZ3JhbSI6IkFnQUFBQUFBQms0RFdaNEMyOHlVUUFBQUFBQT0iLCIzZHNFY2lJbmRpY2F0b3IiOiIwNyJ9",
    "requestId": "1569725246890:cas0stl2:41613:k0s1jw3n:49217"
}
```

## 从R2D2中学习到的验证流程

从 R2D2 库中可以找到一份[带有 java 代码的文档](<https://github.com/spreedly/r2d2/blob/master/test/initial_dev/test_data.md>) ，从这份文档中可以找到与本接口类似的方法 `verifyThenDecrypt`，根据方法中的代码可以知道验证和解密的流程（编写本接口时可以参考），再从中逆推得到模拟参数，将模拟参数发到万事达的接口下测试，测试通过。

> 没有使用 Google Tink 库，使用了 bc 库

1. 从传入的参数中获取 encryptedPrivateKey、ephemeralPublicKey、encryptedMessage、tag。
2. 利用 /core/decrypt/aes 接口解密 encryptedPrivateKey，得到 PKCS8 格式的 privateKey，然后再转成 PrivateKey 对象。同时，将从参数中获取的 ephemeralPublicKey(Bytes 形式) 转成 PublicKey 对象。

```java
KeyFactory asymmetricKeyFactory = KeyFactory.getInstance("EC", "BC");

// ephemeralPublicKeyBytes 转成 PublicKey 对象
ECNamedCurveParameterSpec bcParams = ECNamedCurveTable.getParameterSpec("prime256v1");
ECNamedCurveSpec params = new ECNamedCurveSpec(bcParams.getName(), bcParams.getCurve(), bcParams.getG(), bcParams.getN(), bcParams.getH(), bcParams.getSeed());
PublicKey ephemeralPublicKey = asymmetricKeyFactory.generatePublic(new ECPublicKeySpec(ECPointUtil.decodePoint(asymmetricKeyParams.getCurve(), ephemeralPublicKeyBytes), asymmetricKeyParams));

// 将 PKCS8 转成 PrivateKey 对象
PrivateKey privateKey = asymmetricKeyFactory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8PrivateKey));
```

3. 利用 privateKey 和 ephemeralPublicKey 获取得共享密钥

```java
KeyAgreement keyAgreement = KeyAgreement.getInstance("ECDH", "BC");
keyAgreement.init(privateKey);
keyAgreement.doPhase(ephemeralPublicKey, true);
byte[] sharedSecret = keyAgreement.generateSecret();
```

4. 通过 ephemeralPublicKey 与 共享密钥派生出 symmetricEncryptionKey 和 macKey

> 注意：info 需要传入 "Android"。

```java
HKDFBytesGenerator hkdfBytesGenerator = new HKDFBytesGenerator(new SHA256Digest());
byte[] khdfInput = ByteUtils.concatenate(ephemeralPublicKeyBytes, sharedSecret);
byte[] salt = null;
byte[] info = "Android".getBytes("UTF-8");

hkdfBytesGenerator.init(new HKDFParameters(khdfInput, salt, info));
byte[] sharedKey = new byte[32];
hkdfBytesGenerator.generateBytes(sharedKey, 0, 32);
System.out.println("sharedKey");

// 派生
byte[] symmetricEncryptionKey = new byte[16];
byte[] macKey = new byte[16];
hkdfBytesGenerator.generateBytes(symmetricEncryptionKey, 0, 16);
hkdfBytesGenerator.generateBytes(macKey, 0, 16);
```

5. 利用 macKey 计算出 encryptedMessage 的 HMac，验证是否与 tag 相等

```java
Mac macGenerator = Mac.getInstance("HmacSHA256", "BC");
macGenerator.init(new SecretKeySpec(macKey, "HmacSHA256"));
byte[] expectedTag = macGenerator.doFinal(encryptedMessage);
if (!isArrayEqual(tag, expectedTag)) {
	throw new RuntimeException("Bad Message Authentication Code!");
}
```

6. 利用 symmetricEncryptionKey 解密 encryptedMessage

```java
Cipher cipher = Cipher.getInstance("AES/CTR/NoPadding");
byte[] iv = Hex.Hex.decode("00000000000000000000000000000000");
cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(encryptionKey, "AES"), new IvParameterSpec(iv));
return new String(cipher.doFinal(encryptedMessage), "UTF-8");
```

## 逆推验证过程，获得模拟参数

> 使用了 Google Tink 库

1. 生成 ECC 密钥对、解密 encryptedPrivateKey、将公钥私钥分别转成 ECPublicKey、ECPrivateKey。(参考上面的代码)
2. 利用 Google Tink 库推导出临时公钥与 symmetricKey（symmetricKey=symmetricEncryptionKey + macKey），然后拆分 symmetricEncryptionKey 和 macKey

```java
final byte[] hkdfInfo = "Android".getBytes("UTF-8");
final EciesHkdfSenderKem.KemKey hkdFwithSHA256 = eciesHkdfSenderKem.generateKey("HmacSha256", null, hkdfInfo, 32, EllipticCurves.PointFormatType.UNCOMPRESSED);

final byte[] ephemeralPublicKeyFromGoogle = hkdFwithSHA256.getKemBytes();
System.out.println("Google ephemeralPublicKey By Base64: " + Base64.Base64.encode(ephemeralPublicKeyFromGoogle));

final byte[] symmetricKey = hkdFwithSHA256.getSymmetricKey();
final String symmetricKeyFromGoogle = Hex.Hex.encode(symmetricKey);
System.out.println("Google symmetricKey By Hex: " + symmetricKeyFromGoogle);

// 拆分
final String symmetricEncryptionKey = symmetricKeyFromGoogle.substring(0, symmetricKeyFromGoogle.length() / 2);
final String macKeyHex = symmetricKeyFromGoogle.substring(symmetricKeyFromGoogle.length() / 2);
System.out.println("symmetricEncryptionKeyHex: " + symmetricEncryptionKey);
System.out.println("macKeyHex: " + macKeyHex);
```

3. 随便编写明文数据：1234567812345678
4. 利用 symmetricEncryptionKey 加密明文数据，得到 encryptedMessage

```java
SecretKey symmetrickey = new SecretKeySpec(Hex.Hex.decode(symmetricEncryptionKey), "AES");
Cipher encrypt = Cipher.getInstance("AES/CTR/NoPadding", provider);
IvParameterSpec ivParameterSpec = new IvParameterSpec(Hex.Hex.decode("00000000000000000000000000000000"));
encrypt.init(Cipher.ENCRYPT_MODE, symmetrickey, ivParameterSpec);
final byte[] encryptedMessageBytes = encrypt.doFinal(plainText.getBytes("UTF-8"));
final String encryptedMessage = Base64.Base64.encode(encryptedMessageBytes);
System.out.println("encryptedMessage By Base64: " + encryptedMessage);
```

5. 利用 macKey 计算 encryptedMessage 的 HMAC，获得 tag

```java
final Mac mac = Mac.getInstance("HmacSHA256", provider);
SecretKey macKey = new SecretKeySpec(Hex.Hex.decode(macKeyHex), "HMAC");
mac.init(macKey);
final byte[] hmac = mac.doFinal(encryptedMessageBytes);
System.out.println("tag By Base64: " + Base64.Base64.encode(hmac));
```

通过上述步骤，获得测试数据与万事达响应如下：

**请求**

```json
{
"encryptedPrivateKey": "PrvK5yZyi2BZ6zYpdl4AQhCul+jIuBtYOWsFTR1DKcujrKiEXBiwabzGKyKGo1uv3R0jBKYHBNLZhUxW/ATJ5lADbj99+LZLPOcXJ2rkk+wz0X5fQ/sa3TBxhbNYMb1+suD7loUb25e2NRLgX+ayOC0=",
"paymentToken": {
	"encryptedMessage": "pjNMU2+5GKT4YPX8lxRObw==",
	"ephemeralPublicKey": "BMZiBWWx9fAe5my37T148qoBzenLJI1Sncbqh15oAwG7eb5Omoii8rGqWeQ8oAwQSdVv3Ave3QWl26J+95ccOPc=",
	"tag": "6qfNLn9vALYO7OFPyStk7ANlEC4JhTRBej1HJ5Qu+c0="
    }
}
```

**响应**

```json
{
"verified": true,
"tokenData": "MTIzNDU2NzgxMjM0NTY3OA==",
"requestId": "1569745799386:cas0stl2:40566:k0s1jfu3:50591"
}
```

将 tokenData 经过 Base64 => asc 后得到明文数据：1234567812345678