# 第九章 - 线程

> 概念

线程是一个程序内部的顺序控制流，可以理解为，线程是一个程序里不同的执行路径。线程应该是从main方法出来一条或多条分支，main方法继续执行，同时这些分支也一起执行，这些分支就是线程。其中main方法叫主线程。

> 解释

在以前，所显示出来的多线程，其实是因为CPU运算速度很快，它把时间分片，这个线程执行一会，那个执行一会，对人来说，就像多个线程同时执行一样，实际上一个CPU在一个时间点，仍然是执行一个线程。但现在CPU普遍都是多核的，这就确实是多线程。（除了DOX系统，都支持多线程）

> 进程

只是一个静态概念，就像机器上的一个txt文件，当文件要执行，进程被放到内存中，这时进程产生了，但进程还没有开始。平常所说的进程执行是指main方法主线程开始执行。

> 注意

1. java的线程是通过 java.lang.Thread 类来实现的
2. VM（虚拟机）启动时会有一个由main所定义的线程
3. 可以通过创建Thread的实例来创建新线程
4. 每个线程都是通过某个特定的Thread对象所对应方法run()来完成其操作的，方法run()称为线程体。
5. 通过调用Thread类的start()方法来启动一个线程。

## 1 线程的创建和启动

> 方式一

创建 - 新建一个类，实现Runnable接口，说明这个类作为线程运行，Runnable中同样有run方法，要重写。

启动 - 一定要实例化 Thread

> 方式二

创建 - 类直接继承 Thread类，同样要重写run方法。

启动 - 因为所需要作为线程的类已经是继承Thread了，所以main中可以不用再实例化Thread，直接调用start方法。

> 推荐

因为java是单继承的，如果继承了Thread类，那么就不能继承其他了，欠缺灵活，所以推荐用接口。

## 2 线程状态转换

1. start，只是告诉CPU可以执行了，并不是马上执行，要等待CPU，因为CPU可能在运行着别的程序。
2. 当运行中，有某些情况发生，就会进入阻塞状态，进入等待，阻塞解除后，才继续

## 3 线程控制的基本方法

- isAlive() - 判断线程是否“活”着，除了没有启动和终止，其他都是活着。
- currentThread - 返回对当前正在执行的线程对象
- getPriority(); - 获得线程优先级
- setPriority - 设置线程优先级，优先级决定运行时间片的长短
- Thread.sleep() - 将当前线程睡眠指定毫秒数，即让线程停多久。
  - sleep括号填的是毫秒，1000毫秒=1秒
  - 在哪个线程调用sleep，就让哪个线程睡眠
  - 这个方法可以让子线程结束，但不是最好的方法，其实只要结束run方法就代表线程结束了。可以设置一个boolean变量，写上一个可以改变boolean的方法，来控制run的结束，这才是比较好的让子线程结束的方法。
  - sleep是一个静态方法。
  - 重写方法抛出的异常不能比原方法所抛出异常类型范围更大，即原方法没有的异常不能在重写方法中抛出。尽量不要用stop方法，比interrupt更粗暴

- join() - 合并该线程，意思是，等待该线程终止。
  - 例如，在main方法中运行t.join()，t是Thread实例，那么：main方法就不会和t线程同时执行，而是先执行完t线程后，再执行main下面的语句。

- yield() - 让出CPU，当前线程进入就绪队列等待。

## 4 线程的优先级别

优先级关系到CPU运行该线程的长短，用数字表示，范围从1到10，默认是5。

## 5 线程同步

> 说明

你有3000块钱，去银行取钱，存折和银行卡都可以取，你用存折去银行取钱，取2000，银行取钱是先检查是否够2000，发现够，把钱吐出，再更改为1000，就在系统检测完后，准备给你钱的时候，你老婆拿着银行卡同样在别的地方同样取2000，系统再检测账户，因为钱还没有更改，所以够2000，系统又决定给你老婆2000，然后你也能拿到2000。所以就会出现线程的问题。

问题在于：一个线程在执行的时候，被另一个线程打断了，因为CPU是各个线程运行一段时间的。

解决：当一个线程调用一个资源时，这个资源只归这个线程独占，其他线程不能访问。

> synchronized 关键字

锁定当前对象，别的对象不能调用，即使当前这个线程sleep了

```java
// 锁定当前对象，在一个线程执行这个关键字大括号内容（资源）时，不会被另一个线程打断，即CPU不会把当前线程停止，让另一个线程执行。
// 这种写法是把关键字写在方法体里
synchronized(this) {
    ...
}

// 另一种写法，将 synchronized 关键字可以写在方法声明中
public synchronized void add(String name) {
    ...
    // 那么，线程在运行这个方法时同样锁定
}
```

> 死锁

产生情况，当一个程序，它需要锁定两个对象（1,2）才可以执行下去，而它只锁定了其中一个对象，姑且称为1。在这同时，存在另一个程序，它也需要锁定两个对象，也只锁定了其中一个对象，称为2。这样，两个程序都需要对方所锁定的对象，都需要等待对方解开锁定，导致两个程序都停止等待了，就形成了死锁。（当然还有多线程的死锁）

解决 - 尽量锁定一个对象，或者锁定的范围更大

**注意**

1. 有写synchronized关键字的程序，的确是锁定了，但只是锁定了那个程序，不能阻止其他线程访问其他程序。同样，当其他线程在其他程序中改变了呗锁定的程序中的变量，那么锁定程序中的变量通用受影响。所以，涉及到通用资源的程序都应该被锁定（就像银行账户里的钱，访问到这个资源的所以程序都应该锁定）。

   例如，b本来值是100，在被锁定的程序中b的值变成1000，这时，其他线程访问其他程序，其他程序中同样有b，打印出来b不是100，而是1000。同理，在这个基础上，其他线程在其他程序，把b改为2000，这时被锁定的程序中的b的值同样会变的，变为2000。

2. 在多个线程对同一个变量改的时候要加锁，读的时候不用锁。

> 经典问题 - 生产者消费者

模拟做馒头和吃馒头

- wait 方法 - Object的方法，不是Thread的，是让当前的访问这里的被锁定的线程等待。要有锁定才能有wait，wait需要有人叫醒，一旦wait，线程就不再拥有所执行程序的锁，只有醒了才找回。
- notify 方法 - Object的方法，叫醒当前的，在这个程序上wait的线程。
  - 如果不叫醒，一旦wait，就不会醒，停在那里了（wait和notify一般是对应的）
  - notify不是叫醒自己，不能自己叫醒自己，而是叫醒在这个对象上等待的其他一个线程。notifyAll就是叫醒其他所有线程。