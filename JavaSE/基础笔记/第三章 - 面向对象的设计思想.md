# 第三章 - 面向对象的设计思想

## 注意和规范

- 通过成员变量（属性、静态属性）和方法（动态属性）定义类
- 符合某类食物特征的事物，实例化的，那就是对象，比如学生是类，而具体的某个学生就是这个类的实例化，就是对象
- 方法与当前所要达成的目的没有关系的时候，不用封装到类里
- 成员变量可不赋初值直接使用，但是局部变量要赋初值才可以使用
- 引用：除基本类型外的变量类型，需要用new来创造对象（一小块内存指向一大块内存，虽然java里没有指针，但是引用类型都是指针）
- 使用 `.` 来使用成员变量或方法
- 非静态方法是针对每个对象进行调用，即必须先new一个对象出来，再调用这个方法

## 1 类的关系

- **关联** - 最弱的关系
- **继承** - 能说通 xx是一种xx 这句话时，如 学生是人
- **聚合** - xx是xx的一部分，又分为组合和聚集
  - 必不可少，密不可分的关系 - 又叫做**组合**
  - 其余的叫聚集
- **实现**
- **多态**

## 2 构造方法

> 定义

使用 new + 构造方法创建一个新的对象，是在勒种的一个用来初始化对象的函数，与所在的类同名，没有返回值，连 `void` 都没有，可以有 `public` 那些。

> 注意

当没有指定构造方法时，编译器自动帮你指定一个空的构造方法。一旦你在类里定义了一个构造方法，则编译器不再帮你添加空的构造方法，如果此时还希望使用空的构造方法来初始化对象，需要手动写一个空的构造方法。

## 3 方法的重载

> 定义

在一个类中可以定义有相同名字，但参数不同的多个方法（参数不同在于：参数个数或参数类型）

> 注意

1. 当参数相同时（即参数个数与参数类型完全相同），不能使用是否有返回值或不同的返回值类型来构成方法的重载，这种叫重名，是错误的
2. 构造方法也可以重载

## 4 关键字

### 4.1 this

一般会出现在类的定义里，对哪个对象调用该方法，this就指向谁，this指向自身对象。

### 4.2 static

1. 在类中，用static什么的成员变量为静态成员变量，内存中存放在数据区，是该类的公用变量，在第一次使用时被初始化。对于该类的所有对象来说，static成员变量只有一份（即使没有对象也有一份）。访问时，每个对象访问都是同一块内容。当没有对象时，可以使用 `类名.xxx` 来方法。
2. 用 static 声明的方法为静态方法，在 static方法中不可直接访问非static，必须使用 `对象.xxx` 来访问。

### 4.3 package

> 作用

包，用于区分开同名的类，也用来对项目代码结构分层。相当于在文件外包了一层外壳，写在java源文件的第一条语句。没有写的话，则为无名包。这种类叫裸体类。

> 起名

约定徐成的用公司域名倒过来，比如，www.tjwoods.com，则用 com.tjwoods.xxx （xxx可以是项目或者其他细分，如果再细分，就继续使用 `.`），最后有 “;”

> 注意

1. java编译器把包对应文件系统的目录管理，package语句中，用 `.` 来指明包的层次
2. 在使用cmd 运行时，如果累有包名，需要把包名写全

### 4.4 import

> 作用

引入被包装了的类，在访问时不用再写上引用类的包名

> 注意

1. 对于不同的源文件，import的路径是不同的
2. 一些基本类，例如java中使用的java.lang 是不需要用import的
3. 将自己写的类打成jar包：使用 jar -cvf xxx.jar

### 4.5 继承

> 定义

使用 `extends` 关键字实现类的继承机制。继承后，紫烈自动拥有父类（基类）的所有成员（成员变量和方法）

> 注意

java 只支持单继承，不允许多继承

### 4.6 访问控制符 / 权限修饰符

> 定义

访问控制符就是写在类、变量、方法前的一个关键字，如 `public` 等等

> 作用

1. 用来限制其他对象对该类对象成员的访问权限
2. 对于类的权限修饰 只有 `public` 和 `default` ，不写时默认为 default
   - public 类可以在任意地方访问
   - default类只可以被同一个包内部的类访问

> 划分

- private - 私有，只有在这个类里可以访问
- default - 当不写权限控制符时，默认为包权限，即同一个包内可以访问
- protected - 受保护，同一包内和这个类的子类可以访问
- public - 均可访问

> 注意

protected时，虽然子类继承了父类的一切，拥有父类的所有成员（包括private成员），但是成员中的private成员不能被子类**直接访问**，但是可以通过 修饰符为 public 的 get/set 方法获取。

### 4.7 方法的重写

> 定义

1. 在子类可以根据需要对从基类和总继承来的方法进行重写
2. 重写方法必须和被重写方法具有相同的方法名，参数列表和返回值类型，即完全相同
3. 重写方法补鞥呢使用比被重写方法更严格的访问权限

> 注意

当重写时，重写的方法名、参数列表、返回值类型不同，编译器不会报错，因为它认为这是一个新方法，而不是重写

### 4.8 super

> 作用

在 java 类中，使用super类引用基类的成分

（当子类对象被new出来时，子类中其实包含一个父类对象，我们用this来指向自身【子类】，用super来指向这个子类的父类对象）

> 继承中的构造方法

1. 子类的构造过程中**必须**调用其基类的构造方法，即在子类构造前要先调用基类的构造方法
2. 子类可以在自己的构造方法中使用 `super(argument_list)` 调用其基类的构造方法。同理可以使用 `this(argument_list)` 调用本身的构造方法
3. 子类中如果要调用super，必须写在子类构造方法的第一行
4. 如果子类的构造方法中没有显示第调用基类的构造方法，则系统默认调用基类无参数的构造方法
5. 如果子类构造方法中既没有显示调用基类构造方法，而基类中又没有无参数的构造方法，则编译出错

### 4.9 final 

> 作用

1. final的变量的值不能被改变
2. final的方法不能被重写，final的类不能被继承

## 5 Object 类

> 定义

1. Object 类是所有类的根基类
2. 如果在类的生命中未使用 `extends` 关键字指明其基类，则默认基类为 `Object` 类。

### 5.1 toString

1. 返回值是 String 类型，描述当前对象的有关信息
2. 在进行 String 与其它类型数据的连接操作时，如：System.out.println("info" + person)，将自动调用该对象的 `toString` 方法。
3. 可以根据需要在用户自定义类型中重写 toString() 方法

### 5.2 equal

1. 提供定义对象是否“相等”的逻辑

2. 默认情况下，既没有重写钱，equal定义为：

   x.equals(y)，只有当x和y是同一个对象时返回true，否则为false

3. 有些类重写了equals方法，例如 String 、Date 等

## 6 对象转型

> 规则

1. 基类的引用类型变量可以指向其子对象，比如要求输入参数“动物”，输入“狗”的对象，也是可以的，因为狗也是动物
2. 基类的引用不可以访问其资料对象新增加的成员（属性和方法），比如要求输入参数“动物”，你传入了狗，这个时候狗这个对象是使用基类来声明的，在方法中不能使用狗中特有的成员，只能当作动物对待
3. 可以使用 `引用变量 instanceof 类名` 来判断该引用型变量所 “指向” 的对象是否属于该类或该类的子类
4. 子类的对象可以当作基类的对象来使用称为向上转型（upcasting），反之叫向下转型（downcasting）或者强制转换。

## 7 动态绑定

> 定义

动态绑定是指在执行期间（cmd中 java xxx 时），而非编译期间（cmd中 javac xxx时），判断所引用对象的实际类型，根据其实际类型调用其相应的方法。

> 作用

可扩展性到了极致。

> 说明

比如，学生、老师是人的子类。人、学生和老师的类中都存在一个“放松”的方法，但是两者的实现方式不同，那么我调用的是人的放松方法，那么，当我传入的是学生的对象时候，就会自动调用学生本身的放松方法，而当我传入老师的对象时，就会调用老师的放松方法。

## 8 抽象类

> 定义

1. 用 `abstract` 关键字来修饰一个类时，这个类叫做抽象类
2. 用 `abstract` 关键字来修饰一个方法时，这个类叫做抽象方法
3. 含有抽象方法的类必须被声明为抽象类，抽了西必须被继承，抽象方法必须被重写。
4. 抽象类不能被实例化，即不能被new出来
5. 抽象方法只需声明，而不需要实现

> 理解

1. 抽象方法没有实现的必要，因为子类必须重写。但是却需要定义，因为要有重写才有多态。那么方法体里就没有语句，但这也算作一种实现，所以为了准确定义之定义不实现的方法，写成

```java
public abstract void enjoy();
```

2. 如果子类中，不想吧父类的抽象方法重写，那么子类定义成抽象类就可以了，但是注意，抽象类是不能被实例化的。

## 9 接口 interface

> 作用

java是单继承的，但是现实中存在多继承的情况，例如金丝猴是动物，同时也是值钱的东西。使用接口就可以解决这种多继承的现象。

> 定义

1. 接口是抽象方法和常量值的定义集合
2. 从本质上讲，接口是一种特殊的抽象类，这种抽象类只包含常量和方法定义，而没有变量和方法的实现。（即类里所有方法都是抽象，所有变量都是静态final不能改变的变量）

> 注意

1. 多个无关的类可以实现同一接口
2. 一个类可以实现多个无关的接口
3. 与集成关系类似，接口与实现类之间存在多态性
4. 接口中所有方法不用写abstract，都是抽象的，所以必须全部实现
5. 使用 `implements` 来实现接口
6. 实现多个接口时，用逗号隔开

> 特性

1. 接口中声明的属性**默认**为 public static final，也只能是这样
2. 接口中只能定义抽象方法，而且不写 abstract 照样是抽象方法，这些方法默认都为public，也只能为public
3. 接口可以继承其他接口，并添加新的属性和抽象方法
